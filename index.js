import TelegramBot from 'node-telegram-bot-api';
import fetch from 'node-fetch';
import 'dotenv/config';
import express from 'express';

const bot = new TelegramBot(process.env.BOT_TOKEN, { polling: true });

const parseAmount = (amount) => {
    console.log('Parsing amount:', amount);
    if (amount.toLowerCase().endsWith('k')) {
        return parseFloat(amount.replace('k', '').replace(/,/g, '')) * 1000;
    } else if (amount.toLowerCase().includes('tri·ªáu')) {
        return parseFloat(amount.replace('tri·ªáu', '').replace(/,/g, '').trim()) * 1000000;
    }
    return parseFloat(amount.replace(/[^\d.]/g, ''));
};

const sendErrorMessage = (chatId, error) => {
    console.error('Error:', error);
    bot.sendMessage(chatId, '‚ö†Ô∏è *Oops! ƒê√£ c√≥ l·ªói x·∫£y ra.* Vui l√≤ng th·ª≠ l·∫°i sau nh√©! üò¢', { parse_mode: 'Markdown' });
};

const sendInlineKeyboard = (chatId) => {
    console.log('Sending inline keyboard to chatId:', chatId);
    const options = {
        reply_markup: {
            inline_keyboard: [
                [
                    { text: 'üìâ T·ªïng chi', callback_data: 'totalExpense' },
                    { text: 'üìà T·ªïng thu', callback_data: 'totalIncome' }
                ],
                [
                    { text: 'üí∞ T·ªïng c√≤n l·∫°i', callback_data: 'totalRemaining' }
                ],
                [
                    { text: 'üóëÔ∏è X√≥a d·ªØ li·ªáu', callback_data: 'deleteAllData' }
                ]
            ]
        }
    };

    bot.sendMessage(
        chatId,
        'üéØ *B·∫°n mu·ªën l√†m g√¨ ti·∫øp theo?* H√£y ch·ªçn m·ªôt trong c√°c m·ª•c b√™n d∆∞·ªõi nh√©! üëá',
        { parse_mode: 'Markdown', ...options }
    );
};

const callApi = async (url) => {
    try {
        console.log('Calling API with URL:', url.toString());
        const res = await fetch(url);
        if (!res.ok) {
            throw new Error(`HTTP error! Status: ${res.status}`);
        }
        const jsonResponse = await res.json();
        console.log('API Response:', jsonResponse);
        return jsonResponse;
    } catch (err) {
        console.error('API Call Error:', err.message);
        throw new Error('API call failed');
    }
};

bot.on('message', (msg) => {
    const chatId = msg.chat.id;
    console.log('Received message:', msg.text);
    if (msg.text === '/start') {
        const userName = msg.from.first_name || 'b·∫°n';
        bot.sendMessage(
            chatId,
            `üéâ *Xin ch√†o, ${userName}!*\n\nCh√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi bot qu·∫£n l√Ω t√†i ch√≠nh c√° nh√¢n. üè¶\n\nB·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c l·ªánh sau:\n- üìå Ghi chi ti√™u: \`15k ƒÉn s√°ng\`\n- üìå Ghi thu nh·∫≠p: \`+7tri·ªáu ti·ªÅn l∆∞∆°ng\`\n- üìâ Xem t·ªïng chi: \`t·ªïng chi\`\n- üìà Xem t·ªïng thu: \`t·ªïng thu\`\n- üí∞ Xem s·ªë ti·ªÅn c√≤n l·∫°i: \`t·ªïng c√≤n l·∫°i\`\n\nH√£y b·∫Øt ƒë·∫ßu qu·∫£n l√Ω t√†i ch√≠nh c·ªßa b·∫°n ngay h√¥m nay nh√©! üöÄ`,
            { parse_mode: 'Markdown' }
        );
    }
});

const handleTransaction = async (chatId, type, amount, note, timestamp) => {
    try {
        console.log('Handling transaction:', { chatId, type, amount, note, timestamp });
        const url = new URL(process.env.WEBHOOK_URL);
        url.searchParams.append('amount', amount);
        url.searchParams.append('type', type);
        url.searchParams.append('note', note);
        url.searchParams.append('timestamp', timestamp);

        const data = await callApi(url);
        console.log('Transaction Response:', data);
        if (data.status === 'success') {
            bot.sendMessage(
                chatId,
                `‚úÖ *Ghi nh·∫≠n th√†nh c√¥ng!*\n\nüìù *Chi ti·∫øt:*\n- üíµ *S·ªë ti·ªÅn*: ${amount.toLocaleString('vi-VN')} VND\n- üóÇÔ∏è *Lo·∫°i*: ${type}\n- ‚úçÔ∏è *Ghi ch√∫*: ${note}\n- üïí *Th·ªùi gian*: ${timestamp}`,
                { parse_mode: 'Markdown' }
            );
            sendInlineKeyboard(chatId);
        } else {
            bot.sendMessage(chatId, `‚ùå Kh√¥ng th·ªÉ ghi nh·∫≠n giao d·ªãch. Ph·∫£n h·ªìi t·ª´ server: *${data.message || 'Unknown error'}*`, { parse_mode: 'Markdown' });
        }
    } catch (err) {
        sendErrorMessage(chatId, err);
    }
};

const handleSummary = async (chatId, action) => {
    try {
        console.log('Handling summary action:', action);
        const url = new URL(process.env.WEBHOOK_URL_V2);
        if (action === 'totalExpense') {
            url.searchParams.append('action', 'getMonthlyTotal');
        } else if (action === 'totalIncome') {
            url.searchParams.append('action', 'getMonthlyIncome');
        } else if (action === 'totalRemaining') {
            const expenseUrl = new URL(process.env.WEBHOOK_URL_V2);
            expenseUrl.searchParams.append('action', 'getMonthlyTotal');
            const incomeUrl = new URL(process.env.WEBHOOK_URL_V2);
            incomeUrl.searchParams.append('action', 'getMonthlyIncome');

            const [expenseData, incomeData] = await Promise.all([callApi(expenseUrl), callApi(incomeUrl)]);

            console.log('Total Remaining Responses:', { expenseData, incomeData });
            if (
                expenseData.status === 'success' &&
                incomeData.status === 'success' &&
                typeof expenseData.total === 'number' &&
                typeof incomeData.total === 'number'
            ) {
                const remaining = incomeData.total - expenseData.total;
                bot.sendMessage(
                    chatId,
                    `üí∞ *T·ªïng ti·ªÅn c√≤n l·∫°i th√°ng ${new Date().getMonth() + 1}:*\n\nüìà *T·ªïng thu*: ${incomeData.total.toLocaleString('vi-VN')} VND\nüìâ *T·ªïng chi*: ${expenseData.total.toLocaleString('vi-VN')} VND\nüíµ *S·ªë ti·ªÅn c√≤n l·∫°i*: ${remaining.toLocaleString('vi-VN')} VND`,
                    { parse_mode: 'Markdown' }
                );
                return;
            } else {
                throw new Error('Invalid response data');
            }
        }

        const data = await callApi(url);
        console.log('Summary Response:', data);
        if (data.status === 'success' && typeof data.total === 'number') {
            const total = data.total.toLocaleString('vi-VN');
            const message =
                action === 'totalExpense'
                    ? `üìâ *T·ªïng chi ti√™u th√°ng ${new Date().getMonth() + 1}:*\nüíµ ${total} VND`
                    : `üìà *T·ªïng thu nh·∫≠p th√°ng ${new Date().getMonth() + 1}:*\nüíµ ${total} VND`;
            bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        } else {
            throw new Error('Invalid response data');
        }
    } catch (err) {
        sendErrorMessage(chatId, err);
    }
};

bot.on('callback_query', async (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const action = callbackQuery.data;
    console.log('Callback query received:', { chatId, action });

    if (action === 'deleteAllData') {
        try {
            const url = new URL(process.env.WEBHOOK_URL_V2);
            url.searchParams.append('action', 'deleteAllData');

            const data = await callApi(url);
            console.log('Delete All Data Response:', data);
            if (data.status === 'success') {
                bot.sendMessage(chatId, 'üóëÔ∏è *D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!* üöÄ', { parse_mode: 'Markdown' });
            } else {
                bot.sendMessage(chatId, `‚ùå Kh√¥ng th·ªÉ x√≥a d·ªØ li·ªáu. Ph·∫£n h·ªìi t·ª´ server: *${data.message || 'Unknown error'}*`, { parse_mode: 'Markdown' });
            }
        } catch (err) {
            sendErrorMessage(chatId, err);
        }
    } else {
        handleSummary(chatId, action);
    }
});

bot.onText(/(.+)/, (msg, match) => {
    const chatId = msg.chat.id;
    const text = match[1].trim();
    console.log('User message:', text);

    const expenseRegex = /^([\d,.]+(?:k|K|tri·ªáu|TRI·ªÜU)?\s+.+)$/;
    const incomeRegex = /^\+([\d,.]+(?:k|K|tri·ªáu|TRI·ªÜU)?\s+.+)$/;
    const totalExpenseRegex = /^t·ªïng chi$/i;
    const totalIncomeRegex = /^t·ªïng thu$/i;
    const totalRemainingRegex = /^t·ªïng c√≤n l·∫°i$/i;

    if (text === '/start') {
        return;
    }

    if (totalExpenseRegex.test(text)) {
        console.log('Handling total expense request');
        handleSummary(chatId, 'totalExpense');
    } else if (totalIncomeRegex.test(text)) {
        console.log('Handling total income request');
        handleSummary(chatId, 'totalIncome');
    } else if (totalRemainingRegex.test(text)) {
        console.log('Handling total remaining request');
        handleSummary(chatId, 'totalRemaining');
    } else if (expenseRegex.test(text)) {
        console.log('Handling expense transaction');
        const [, details] = text.match(expenseRegex);
        const [amount, ...noteParts] = details.split(' ');
        const note = noteParts.join(' ');
        const timestamp = new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' });

        handleTransaction(chatId, 'Ti·ªÅn ra', parseAmount(amount), note, timestamp);
    } else if (incomeRegex.test(text)) {
        console.log('Handling income transaction');
        const [, details] = text.match(incomeRegex);
        const [amount, ...noteParts] = details.split(' ');
        const note = noteParts.join(' ');
        const timestamp = new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' });

        handleTransaction(chatId, 'Ti·ªÅn v√†o', parseAmount(amount), note, timestamp);
    } else {
        console.log('Invalid user message');
        bot.sendMessage(
            chatId,
            '‚ùå *C√∫ ph√°p kh√¥ng h·ª£p l·ªá!*\n\nüìù *V√≠ d·ª•:*\n- `15k ƒÉn s√°ng` (ti·ªÅn ra)\n- `+7tri·ªáu ti·ªÅn l∆∞∆°ng` (ti·ªÅn v√†o)\n- `t·ªïng chi` (t√≠nh t·ªïng chi ti√™u)\n- `t·ªïng thu` (t√≠nh t·ªïng thu nh·∫≠p)\n- `t·ªïng c√≤n l·∫°i` (t√≠nh t·ªïng s·ªë ti·ªÅn c√≤n l·∫°i)',
            { parse_mode: 'Markdown' }
        );
    }
});

console.log('Bot is running...');

const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
    console.log('Health check received');
    res.send('Bot is running!');
});

app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
